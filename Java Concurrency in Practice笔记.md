# 第2章 线程安全性

要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的(Shared)和可变的(Mutable)状态的访问。
共享意味着变理可以由多个线程同时访问，而可变则意味着变量的值在其生命周期内可以发生变化。
当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile变量，显式锁(Explicit Lock)以及原子变量。

如果当多个线程访问一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
不在线程之间共享该状态变量
将状态变理修改为不可变的变量
在访问状态时使用同步
当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替进行，并且在主调代码中不需要任何额外的同步或协同， 这个类都能表现出正确的行为，那么就称这个类是线程安全的。

在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。

无状态对象一定是线程安全的。

在并发编程中，由于不恰当的执行时序而出现不正确的结果的情况，叫做竞态条件Race Condition. 
最常见的竞态条件类型就是“先检查后执行“，Check-Then-Act. 

假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。

在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全状态相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

Java提供了一种内置的锁机制来支持原子性：同步代码块synchronized block。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象为锁。
每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁Intrinsic Lock或监视器锁Monitor Lock。线程在进入同步代码块之前会自动获得锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出的异常退出。获得内置锁的唯一途径就是进入由这个锁护的同步代码块或方法。

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”而不是“调用”。这与pthread互斥体的默认加锁行为不同，POSIX pthread互斥体的获取操作是以“调用”为粒度的。

对于可能被多个线程同时访问的可变状态状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪个锁。

通常，在简单性与性能之间存在着相互制约的因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性。

当执行时间较长的计算或者可能无法快速完成的操作时(例如，网络I/O或控制台I/O)，一定不要持有锁。

# 第3章 对象的共享

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

当线程在没有同步的情况下读取变量，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性out-of-thin-air safety. 
最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量double和long。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变理也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生。

虽然volatile变量很方便，但也存在一些局限性。例如，volatile的语义不足以确保递增操作++的原子性，除非能确保只有一个线程对变理执行写操作。原子变量提供了“读-改-写”的原子操作，并且常常用做一种“更好的volatile变量“。

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

当且仅当满足以下所有条件时，才应该使用volatile变量：
对变量的写入操作不依赖变理的当前值，或者能确保只有单个线程更新变量的值
该变量不会与其他状态变量一起纳入不变性条件中
在访问变量时不需要加锁
发布Publish一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。

不要在构造对象过程中使this引用逸出。

## 3.3 线程封闭

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程的安全性，即使被封闭的对象本身不是线程安全的。

### 3.3.1 Ad-hoc线程封闭

Ad-hoc线程封装是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。
由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术。

### 3.3.2 栈封闭

局部变量的固有属性之一就是封闭在执行线程之中。它们位于执行线程中的栈中，

### 3.3.3 ThreadLocal类

维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。

## 3.4 不变性

不可变对象一定是线程安全的

当满足下列条件时，对象才是不可变的：
对象创建以后其状态就不能修改
对象的所有域都是final类型
对象是正确创建的（在对象的创建期间，this引用没有逸出）

正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域“也是一个良好的编程习惯。

任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。

要安全地发布一个对象，对象的引用以及对象的状态必须同对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：
在静态初始化函数中初始化一个对象引用
将对象的引用保存到volatile类型的域或者AtomicReference对象中。
将对象的引用保存到某个正确构造对象的final类型域中。
将对象的引用保存到一个由锁保护的域中。
在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

对象的发布需求取决于它的可变性：
不可变对象可以通过任意机制来发布
事实不可变对象必须通过安全方式来发布
可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来
在并发程序中命名用和共享对象时，可以使用一些实用的策略，包括：
线程封闭: 线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
只读共享: 在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
线程安全共享: 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

# 第4章 对象的组合

在设计线程安全类的过程中，需要包含以下三个基本要素：
找出构成对象状态的所有变量
找出约束状态变量的不变性条件
建立对象状态的并发访问管理策略
将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。

如果一个类是由多个独立而且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。

如果一状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。

第5章 基础构造模块

5.1 同步容器类

正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。

5.2 并发容器

通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。

5.3 阻塞队列和生产者-消费者模式

在构建高可靠性的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。

第6章 任务执行

每当看到下面这种形式的代码：
new Thread(runnable).start()
并且你希望获得一种更灵活的执行策略时，请考虑使用Executor来代替Thread.

第7章 取消与关闭
